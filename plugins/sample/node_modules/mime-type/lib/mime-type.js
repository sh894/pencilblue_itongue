// Generated by CoffeeScript 1.9.3

/*
 * Module variables.
 * @private
 */

(function() {
  var MimeTypes, defineProperty, extname, extractTypeRegExp, isArray, isString, mediaTyper, minimatch, textTypeRegExp,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  mediaTyper = require('media-typer');

  minimatch = require('minimatch');

  isArray = require('util-ex/lib/is/type/array');

  isString = require('util-ex/lib/is/type/string');

  defineProperty = require('util-ex/lib/defineProperty');

  extname = require('path').extname;

  extractTypeRegExp = /^\s*([^;\s]*)(?:;|\s|$)/;

  textTypeRegExp = /^text\//i;


  /*
   * Module exports.
   * @public
   */

  module.exports = MimeTypes = (function() {
    'use strict';
    var refSources;

    function MimeTypes(db, duplicationProcessWay) {
      if (!(this instanceof MimeTypes)) {
        return new MimeTypes(db);
      }
      defineProperty(this, 'types', {});
      defineProperty(this, 'mimes', {});
      defineProperty(this, 'dupDefault', 0);
      defineProperty(this, 'dupSkip', 1);
      defineProperty(this, 'dupOverwrite', 2);
      defineProperty(this, 'dupAppend', 3);
      defineProperty(this, 'dup', this.dupDefault);
      defineProperty(this, 'extensions', void 0, {
        get: function() {
          var k, mime, ref, result;
          result = {};
          ref = this.mimes;
          for (k in ref) {
            mime = ref[k];
            result[k] = mime.extensions;
          }
          return result;
        }
      });
      if (duplicationProcessWay && indexOf.call([0, 1, 2, 3], duplicationProcessWay) >= 0) {
        this.dup = duplicationProcessWay;
      }
      if (db) {
        this._load(db);
      }
    }


    /*
     * Get the default charset for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    MimeTypes.prototype.charset = function(type) {
      var obj, result;
      if (type && isString(type)) {
        try {
          obj = mediaTyper.parse(type);
          result = obj.parameters.charset;
          if (!result) {
            obj.parameters = void 0;
            type = mediaTyper.format(obj);
            result = this.mimes[type] && this.mimes[type].charset;
          }
          if (!result && obj.type === 'text') {
            result = 'utf-8';
          }
        } catch (_error) {}
      }
      return result;
    };


    /*
     * Create a full Content-Type header given a MIME type or extension.
     *
     * @param {string} str
     * @return {boolean|string}
     */

    MimeTypes.prototype.contentType = function(str) {
      var charset;
      var charset, mime;
      if (str && isString(str)) {
        mime = str.indexOf('/') === -1 ? this.lookup(str) : str;
        if (mime) {
          if (mime.indexOf('charset') === -1) {
            charset = this.charset(mime);
            if (charset) {
              mime += '; charset=' + charset.toLowerCase();
            }
          }
        }
      }
      return mime;
    };


    /*
     * Get the default extension for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    MimeTypes.prototype.extension = function(type) {
      var result;
      if (type && isString(type)) {
        result = extractTypeRegExp.exec(type);
        result = result && this.mimes[result[1].toLowerCase()];
        if (result) {
          result = result.defaultExtension || result.extensions[0];
        }
      }
      return result;
    };


    /*
     * Lookup the MIME types for a file path/extension.
     *
     * @param {string} path
     * @return {undefined|string|array}
     */

    MimeTypes.prototype.lookup = function(path) {
      var extension, result;
      if (path && isString(path)) {
        extension = extname('x.' + path).toLowerCase().substr(1);
        if (extension) {
          result = this.types[extension];
        }
      }
      return result;
    };


    /*
     * Return all MIME types which matching a pattern
     *   [spec](http://tools.ietf.org/html/rfc2616#section-14.1)
     * @param {string} pattern the mime type pattern, For example "video/*", "audio/*", ..
     * @return {array}
     */

    MimeTypes.prototype.glob = function(pattern) {
      var result;
      if (pattern === '*/*') {
        return ['application/octet-stream'];
      }
      result = Object.keys(this.mimes).filter(function(name) {
        return minimatch(name, pattern);
      });
      return result;
    };


    /*
     * Whether the mime type is exist.
     * @param {string} type the mime type
     * @return {boolean}
     */

    MimeTypes.prototype.exist = function(type) {
      return this.mimes.hasOwnProperty(type);
    };

    refSources = ['nginx', 'apache', void 0, 'iana'];


    /*
     * Add a custom mime/extension mapping
     * @param (string) type:  mime type
     * @param (object) mime:  mime object
     *  * "source": "iana",
     *  * "charset": "UTF-8",
     *  * "compressible": true,
     *  * "extensions": ["js"]
     */

    MimeTypes.prototype.define = function(type, mime, dup) {
      var extension, exts, from, i, len, ref, t, to;
      if (!(type && mime && mime.extensions && !this.mimes.hasOwnProperty(type))) {
        return;
      }
      if (dup == null) {
        dup = this.dup;
      }
      exts = mime.extensions;
      if (!isArray(exts)) {
        mime.extensions = [exts];
      }
      exts = [];
      if (mime.charset) {
        mime.charset = mime.charset.toLowerCase();
      }
      ref = mime.extensions;
      for (i = 0, len = ref.length; i < len; i++) {
        extension = ref[i];
        t = this.types[extension];
        if (t) {
          switch (dup) {
            case this.dupSkip:
              continue;
            case this.dupAppend:
              if (isString(t)) {
                t = [t];
              }
              if (indexOf.call(t, type) < 0) {
                t.push(type);
              }
              break;
            case this.dupOverwrite:
              t = type;
              break;
            case this.dupDefault:
              if (isArray(t)) {
                t = t[0];
              }
              from = refSources.indexOf(this.mimes[t].source);
              to = refSources.indexOf(mime.source);
              if (t !== 'application/octet-stream' && from > to || from === to && t.substr(0, 12) === 'application/') {
                if (process.env.DEBUG_MIME) {
                  console.warn("defineMime(" + type + "): the " + extension + " extension is exists on\n" + t + " skipped it.");
                }
                continue;
              } else {
                t = type;
              }
          }
        } else {
          t = type;
        }
        this.types[extension] = t;
        exts.push(extension);
      }
      if (exts.length) {
        mime.extensions = exts;
        this.mimes[type] = mime;
      }
      return exts;
    };


    /*
     * Populate the extensions and types maps from db.
     * @private
     */

    MimeTypes.prototype._load = function(db) {
      return Object.keys(db).forEach((function(_this) {
        return function(type) {
          return _this.define(type, db[type]);
        };
      })(this));
    };

    return MimeTypes;

  })();

}).call(this);
